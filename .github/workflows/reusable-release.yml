name: "ğŸš€ Reusable: Release Creator"

# è§¦å‘å™¨ï¼šå½“ä¸€ä¸ª 'v*' æ ¼å¼çš„æ ‡ç­¾è¢«æ¨é€æ—¶ï¼Œæˆ–æ‰‹åŠ¨è§¦å‘æ—¶è¿è¡Œ
on:
  workflow_call:
    inputs:
      tag:
        description: 'Release tag to create (e.g., v0.0.1)'
        required: false
        type: string
      target_branch:
        description: 'Target branch to base the tag on'
        required: false
        type: string
      prerelease:
        description: 'Mark as pre-release version'
        required: false
        type: string
    secrets:
      # æ–°å¢ï¼šè®©è°ƒç”¨è€…å¯ä»¥ä¼ å…¥ Webhook URL
      RELEASE_WEBHOOK_URL:
        description: 'The URL to send the release notification to'
        required: false # è®¾ç½®ä¸º falseï¼Œè¿™æ ·ä¸é…é€šçŸ¥çš„ä»“åº“å°±ä¸ä¼šæŠ¥é”™
  # æ–°å¢å†…å®¹å¦‚ä¸‹ï¼š
  # æ·»åŠ ä¸€ä¸ª push è§¦å‘å™¨ï¼Œä½†å‘Šè¯‰å®ƒå¿½ç•¥æ‰€æœ‰æ–‡ä»¶çš„å˜æ›´ã€‚
  # è¿™ä¼šé˜»æ­¢ GitHub Actions åœ¨ push æ—¶ä¸ºè¿™ä¸ªæ–‡ä»¶åˆ›å»ºâ€œæ— ä»»åŠ¡è¿è¡Œâ€çš„å¤±è´¥è®°å½•ã€‚
  push:
    paths-ignore:
      - '**'

jobs:
  create-release:
    name: ğŸ“¦ Create Release with GitHub CLI
    permissions:
      contents: write
    runs-on: github-runner

    env:
      WEBHOOK_URL: ${{ secrets.RELEASE_WEBHOOK_URL }}
      GH_TOKEN: ${{ github.token }}

    steps:
      # æ­¥éª¤ 1: æ£€å‡ºä»£ç åº“
      - name: ğŸ”„ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # è·å–æ‰€æœ‰å†å²è®°å½•ï¼Œè¿™å¯¹ gh generate-notes è‡³å…³é‡è¦

      # æ­¥éª¤ 2: æ”¶é›†å‘å¸ƒæ‰€éœ€çš„ä¿¡æ¯
      - name: ğŸ·ï¸ Gather Release Info
        id: release_info
        run: |
          # åˆå§‹åŒ–å˜é‡
          TAG_NAME=""
          TARGET_BRANCH=""
          IS_PRERELEASE=""
          IS_TAG_PUSH="false"

          # 1. ç¡®å®šè§¦å‘æ–¹å¼å’Œæ ‡ç­¾ (Tag)
          if [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/') }}" == "true" ]]; then
            # åœºæ™¯ A: ç”±æ¨é€æ ‡ç­¾è‡ªåŠ¨è§¦å‘
            IS_TAG_PUSH="true"
            TAG_NAME=${GITHUB_REF#refs/tags/}
            echo "âœ… Triggered by tag push."
          elif [[ -n "${{ inputs.tag }}" ]]; then
            # åœºæ™¯ B: ç”±æ‰‹åŠ¨è°ƒç”¨å¹¶ä¼ å…¥ tag è§¦å‘
            TAG_NAME="${{ inputs.tag }}"
            echo "âœ… Triggered manually with input tag."
          else
            # åœºæ™¯ C: æ— æ³•ç¡®å®šæ ‡ç­¾ï¼Œå¤±è´¥
            echo "::error::Could not determine tag. Please provide it via 'inputs' or trigger via a tag push."
            exit 1
          fi
          
          # 2. ç¡®å®šç›®æ ‡åˆ†æ”¯ (Target Branch)
          if [[ -n "${{ inputs.target_branch }}" ]]; then
            TARGET_BRANCH="${{ inputs.target_branch }}"
          else
            TARGET_BRANCH=$(git remote show origin | grep 'HEAD branch' | cut -d' ' -f5 || echo 'main')
          fi

          # 3. ç¡®å®šæ˜¯å¦é¢„å‘å¸ƒ
          if [[ -n "${{ inputs.prerelease }}" ]]; then
            IS_PRERELEASE="${{ inputs.prerelease }}"
          elif [[ "$TAG_NAME" == *-* ]]; then
            IS_PRERELEASE="true"
          else
            IS_PRERELEASE="false"
          fi

          # 4. è·å–ä¸Šä¸€ä¸ªæ ‡ç­¾
          git fetch --tags
          PREVIOUS_TAG=$(git tag --sort=-creatordate | grep -v "^$TAG_NAME$" | head -n 1)
          
          # --- è¾“å‡ºæ‰€æœ‰æ”¶é›†åˆ°çš„ä¿¡æ¯ ---
          echo "tag_name=$TAG_NAME" >> "$GITHUB_OUTPUT"
          echo "previous_tag=$PREVIOUS_TAG" >> "$GITHUB_OUTPUT"
          echo "target_branch=$TARGET_BRANCH" >> "$GITHUB_OUTPUT"
          echo "is_prerelease=$IS_PRERELEASE" >> "$GITHUB_OUTPUT"
          # æ–°å¢ï¼šè¾“å‡ºè§¦å‘ç±»å‹ï¼Œä¾›åç»­æ­¥éª¤ä½¿ç”¨
          echo "is_tag_push=$IS_TAG_PUSH" >> "$GITHUB_OUTPUT"

          echo "--- Release Info Gathered ---"
          echo "ğŸ“ Release Tag: $TAG_NAME"
          echo "ğŸ¯ Target Branch: $TARGET_BRANCH"
          echo "ğŸ“– Previous Tag: ${PREVIOUS_TAG:-'N/A (first release)'}"
          echo "ğŸš€ Is Prerelease: $IS_PRERELEASE"
          echo "âš™ï¸ Triggered by Tag Push: $IS_TAG_PUSH"

      # æ­¥éª¤ 3: ç”Ÿæˆ Release Notes (ä½¿ç”¨æ›´æ–°åçš„ç»Ÿä¸€é€»è¾‘)
      - name: ğŸ“ Generate Release Notes
        id: generate_notes
        run: |
          START_REF="${{ steps.release_info.outputs.previous_tag }}"
          END_REF="${{ steps.release_info.outputs.target_branch }}"
          TAG_NAME="${{ steps.release_info.outputs.tag_name }}"
          IS_TAG_PUSH="${{ steps.release_info.outputs.is_tag_push }}"
          NOTES_FILE="releasenotes.md"

          # åˆå§‹åŒ– HEAD_REF å˜é‡
          HEAD_REF=""
          
          # æ ¹æ®ä¸Šä¸€æ­¥çš„åˆ¤æ–­ç»“æœï¼Œç›´æ¥é€‰æ‹© HEAD å¼•ç”¨
          if [[ "$IS_TAG_PUSH" == "true" ]]; then
            HEAD_REF="$TAG_NAME"
          else
            HEAD_REF="$END_REF"
          fi
          
          echo "Selected HEAD reference for changelog: '$HEAD_REF'"

          # --- ç»Ÿä¸€çš„ API è°ƒç”¨é€»è¾‘ (æ­¤åæ‰€æœ‰é€»è¾‘éƒ½æ— éœ€å†ä¿®æ”¹) ---
          if [[ -n "$START_REF" ]]; then
            echo "This is a subsequent release. Comparing '$START_REF' with '$HEAD_REF'."
            COMMIT_RANGE="$START_REF...$HEAD_REF"
            
            echo "Fetching commits from GitHub API using the 'compare' endpoint..."
            ALL_COMMITS_JSON=$(gh api --paginate "repos/${{ github.repository }}/compare/$COMMIT_RANGE?per_page=100" \
              | jq -s 'map(.commits[]) | map(select(.commit.message | startswith("Merge pull request") | not))'
            )
          else
            echo "This is the first release. Fetching all commits up to '$HEAD_REF'."
            COMMIT_RANGE="$HEAD_REF"
            
            echo "Fetching commits from GitHub API using the 'commits' endpoint..."
            ALL_COMMITS_JSON=$(gh api --paginate "repos/${{ github.repository }}/commits?sha=$COMMIT_RANGE&per_page=100" \
              | jq -s 'flatten | map(select(.commit.message | startswith("Merge pull request") | not))'
            )
          fi

          if [[ -z "$ALL_COMMITS_JSON" || "$ALL_COMMITS_JSON" == "[]" ]]; then
            echo "::warning::Could not find any commits for this release. The generated notes might be empty."
            ALL_COMMITS_JSON="[]" # ç¡®ä¿å˜é‡æ˜¯æœ‰æ•ˆçš„ç©º JSON æ•°ç»„
          fi
          
          echo "Generating changelog for commit range: $COMMIT_RANGE"

          # --- A: ç”Ÿæˆç»Ÿè®¡æ‘˜è¦ ---
          echo "Calculating release statistics..."
          TOTAL_COMMITS=$(echo "$ALL_COMMITS_JSON" | jq 'length')
          STATS_SUMMARY=$(git log "$COMMIT_RANGE" --shortstat --pretty=format:"" | tail -n 1 | xargs)
          FILES_CHANGED=$(echo "$STATS_SUMMARY" | grep -o '[0-9]* files changed' | grep -o '[0-9]*' || echo 0)
          LINES_ADDED=$(echo "$STATS_SUMMARY" | grep -o '[0-9]* insertions(+)' | grep -o '[0-9]*' || echo 0)
          LINES_DELETED=$(echo "$STATS_SUMMARY" | grep -o '[0-9]* deletions(-)' | grep -o '[0-9]*' || echo 0)
          # =================================================================
          # æ ¸å¿ƒä¼˜åŒ–ï¼šä½¿ç”¨ä¸€ä¸ªæ›´å¼ºå¤§çš„ gh api å‘½ä»¤ç›´æ¥ç”Ÿæˆè´¡çŒ®è€…åˆ—è¡¨
          # è¿™ä¸ªå‘½ä»¤ç»“åˆäº†æ‚¨çš„ç®€åŒ–æ€è·¯å’Œæˆ‘ä»¬ä¹‹å‰çš„ä¿®å¤é€»è¾‘
          # =================================================================
          echo "Generating robust contributors list..."
          CONTRIBUTORS_JSON=$(echo "$ALL_COMMITS_JSON" | jq '
            [
              .[] |
              # è·¯å¾„ 1: å¦‚æœ .author å­˜åœ¨ä¸”ä¸æ˜¯ Botï¼Œä½¿ç”¨å®ƒ (æœ€ä½³æƒ…å†µ)
              if .author and .author.type != "Bot" then
                {login: .author.login, html_url: .author.html_url, type: "github_user"}
              # è·¯å¾„ 2 (å›é€€): å¦‚æœ .author ä¸º nullï¼Œåˆ™ä½¿ç”¨ .commit.author.name
              elif (.commit.author.name | test("bot|actions"; "i") | not) then
                {login: .commit.author.name, html_url: null, type: "git_author"}
              # å…¶ä»–æƒ…å†µï¼ˆå¦‚ Bot æäº¤ï¼‰åˆ™å¿½ç•¥
              else
                empty
              end
            ] | unique_by(.login) # æœ€åå¯¹ç»“æœè¿›è¡Œå»é‡
          ')
          CONTRIBUTORS_COUNT=$(echo "$CONTRIBUTORS_JSON" | jq 'length')
          
          > "$NOTES_FILE"
          echo -e "## ğŸ“Š Release Summary\n" >> "$NOTES_FILE"
          echo -e "- ğŸ“ **Total commits**: $TOTAL_COMMITS" >> "$NOTES_FILE"
          echo -e "- ğŸ‘¥ **Contributors**: $CONTRIBUTORS_COUNT" >> "$NOTES_FILE"
          echo -e "- ğŸ“ **Files changed**: $FILES_CHANGED" >> "$NOTES_FILE"
          echo -e "- â• **Lines added**: $LINES_ADDED" >> "$NOTES_FILE"
          echo -e "- â– **Lines deleted**: $LINES_DELETED\n" >> "$NOTES_FILE"

          # --- B: ç”Ÿæˆåˆ†ç±»å˜æ›´æ—¥å¿— ---
          echo "Generating categorized changelog..."
          COMMIT_LOG=$(echo "$ALL_COMMITS_JSON" | jq -r '
            .[] | 
            "- [\(.sha | .[:7])](\(.html_url)) \(.commit.message | split("\n")[0]) - by \(.author.login // .commit.author.name)"
          ')
          
          echo -e "## ğŸš€ What's Changed\n" >> "$NOTES_FILE"
          all_patterns=()
          while IFS='|' read -r pattern emoji display_name; do
            pattern=$(echo "$pattern" | xargs); emoji=$(echo "$emoji" | xargs); display_name=$(echo "$display_name" | xargs)
            all_patterns+=("$pattern")
            commits=$(echo "$COMMIT_LOG" | grep -i -E -- "$pattern" || true)
            if [[ -n "$commits" ]]; then
              echo -e "\n### $emoji $display_name\n" >> "$NOTES_FILE"
              echo "$commits" >> "$NOTES_FILE"
            fi
          done <<'CATEGORIES'
            feat(ure)?(\(.*\))?:      | âœ¨ | New Features
            fix(es)?(\(.*\))?:        | ğŸ› | Bug Fixes
            refactor(\(.*\))?:        | ğŸ”¨ | Refactoring
            perf(\(.*\))?:            | âš¡ï¸ | Performance Improvements
            ci(\(.*\))?:              | ğŸ¤– | CI/CD
            docs?(\(.*\))?:           | ğŸ“š | Documentation
            build(\(.*\))?:           | ğŸ“¦ | Build System
            test(\(.*\))?:            | âœ… | Tests
            \bchore(\(.*\))?:         | âš™ï¸ | Chores
          CATEGORIES
          ALL_PATTERNS_REGEX=$(IFS='|'; echo "${all_patterns[*]}")
          other_commits=$(echo "$COMMIT_LOG" | grep -i -v -E "$ALL_PATTERNS_REGEX" || true)
          if [[ -n "$other_commits" ]]; then
            echo -e "\n### ğŸ”§ Other Changes\n" >> "$NOTES_FILE"
            echo "$other_commits" >> "$NOTES_FILE"
          fi

          if [[ -n "$START_REF" ]]; then
            echo -e "\n\n**Full Changelog**: [$START_REF...$TAG_NAME](${{ github.server_url }}/${{ github.repository }}/compare/$START_REF...$TAG_NAME)" >> "$NOTES_FILE"
          fi

          # =================================================================
          # æ ¸å¿ƒä¿®æ”¹ï¼šç”Ÿæˆä»…åŒ…å«ç”¨æˆ·åçš„ç®€æ´è´¡çŒ®è€…åˆ—è¡¨
          # =================================================================
          echo "Formatting simplified contributors list..."
          if [[ $CONTRIBUTORS_COUNT -gt 0 ]]; then
            # ä½¿ç”¨ä¸€ä¸ª jq å‘½ä»¤é«˜æ•ˆåœ°å°†æ‰€æœ‰è´¡çŒ®è€…æ ¼å¼åŒ–ä¸º Markdown åˆ—è¡¨
            CONTRIBUTORS_MD=$(echo "$CONTRIBUTORS_JSON" | jq -r '.[] | "- @\(.login)"')
            
            echo -e "\n## â¤ï¸ Contributors\n" >> "$NOTES_FILE"
            echo -e "A huge thank you to everyone who contributed to this release:\n" >> "$NOTES_FILE"
            echo -e "${CONTRIBUTORS_MD}\n" >> "$NOTES_FILE"
          fi

          echo "Generated changelog content:"
          cat "$NOTES_FILE"
          
          echo "changelog_path=$NOTES_FILE" >> "$GITHUB_OUTPUT"

      # æ­¥éª¤ 4: ä½¿ç”¨ GitHub CLI åˆ›å»ºå‘å¸ƒ
      - name: ğŸ‰ Create GitHub Release and Tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ steps.release_info.outputs.tag_name }}
          TARGET_BRANCH: ${{ steps.release_info.outputs.target_branch }}
          IS_PRERELEASE: ${{ steps.release_info.outputs.is_prerelease }}
        run: |
          # å‡†å¤‡ gh CLI å‘½ä»¤çš„é€šç”¨å‚æ•°æ•°ç»„
          # æ— è®ºæ˜¯ create è¿˜æ˜¯ editï¼Œè¿™äº›å‚æ•°éƒ½é€‚ç”¨
          args=(
            --title "ğŸš€ Release $TAG_NAME"
            --notes-file "${{ steps.generate_notes.outputs.changelog_path }}"
          )
          
          # å¦‚æœæ˜¯é¢„å‘å¸ƒï¼Œæ·»åŠ  --prerelease æ ‡å¿—
          if [[ "$IS_PRERELEASE" == "true" ]]; then
            args+=(--prerelease)
          fi
          
          echo "Checking for existing release with tag: $TAG_NAME"
          
          # ä½¿ç”¨ if æ¡ä»¶åˆ¤æ–­ gh release view çš„é€€å‡ºçŠ¶æ€ç 
          # if gh ...; then ...; else ...; fi ç»“æ„æ˜¯ shell çš„æ ‡å‡†è¯­æ³•
          if gh release view "$TAG_NAME" >/dev/null 2>&1; then
            echo "âœ… Release '$TAG_NAME' already exists. Updating it..."
            # å¦‚æœå­˜åœ¨ï¼Œå°±ç¼–è¾‘ç°æœ‰çš„ Release
            gh release edit "$TAG_NAME" "${args[@]}"
          else
            echo "ğŸ†• Release '$TAG_NAME' not found. Creating a new one..."
            # å¦‚æœä¸å­˜åœ¨ï¼Œå°±åˆ›å»ºæ–°çš„ Release
            # æ³¨æ„ï¼šcreate å‘½ä»¤éœ€è¦é¢å¤–çš„ --target å‚æ•°
            gh release create "$TAG_NAME" \
              --target "$TARGET_BRANCH" \
              "${args[@]}"
          fi

      # æ­¥éª¤ 5: åœ¨ Release åˆ›å»ºæˆåŠŸåå‘é€é€šçŸ¥
      - name: 'ğŸ”” Send Webhook Notification'
        # æ¡ä»¶ï¼šæ£€æŸ¥ä¼ å…¥çš„ç¯å¢ƒå˜é‡ WEBHOOK_URL æ˜¯å¦ä¸ºç©º
        if: ${{ success() && env.WEBHOOK_URL != '' }}
        env:
          TAG_NAME: ${{ steps.release_info.outputs.tag_name }}
          TARGET_BRANCH: ${{ steps.release_info.outputs.target_branch }}
          IS_PRERELEASE: ${{ steps.release_info.outputs.is_prerelease }}
          REPO_NAME: ${{ github.repository }}
          RELEASE_URL: "https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.tag_name }}"
        run: |
          # è½¬æ¢å¸ƒå°”å€¼
          PRERELEASE_BOOL=$( [[ "$IS_PRERELEASE" == "true" ]] && echo true || echo false )
          # å‡†å¤‡ JSON payload
          JSON_PAYLOAD=$(printf '{ 
          "repository": "%s", 
          "tag": "%s", 
          "target_branch": "%s", 
          "prerelease": %s, 
          "release_url": "%s", 
          "message": "ğŸš€ New release %s has been published for %s!" 
          }' 
          "$REPO_NAME" 
          "$TAG_NAME" 
          "$TARGET_BRANCH" 
          "$PRERELEASE_BOOL" 
          "$RELEASE_URL" 
          "$TAG_NAME" 
          "$REPO_NAME")

          echo "Sending notification to webhook..."
          echo "Payload: $JSON_PAYLOAD" 
          
          # ä½¿ç”¨ curl å‘é€ POST è¯·æ±‚
          curl -X POST -H "Content-Type: application/json" \
             -d "$JSON_PAYLOAD" \
             "$WEBHOOK_URL"

      # æ­¥éª¤ 6: æˆåŠŸé€šçŸ¥
      - name: âœ… Release Created Successfully
        if: success()
        run: |
          echo "ğŸŠ Release created successfully!"
          echo "ğŸ“¦ Version: ${{ steps.release_info.outputs.tag_name }}"
          echo "ğŸ”— View at: https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.tag_name }}"

      # æ­¥éª¤ 7: å¤±è´¥é€šçŸ¥
      - name: âŒ Release Creation Failed
        if: failure()
        run: |
          echo "ğŸ’¥ Release creation failed! Please check the logs."
